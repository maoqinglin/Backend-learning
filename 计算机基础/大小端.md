# 一、什么是大小端

计算机正常的内存增长方式是从低到高(当然栈不是)，**取数据方式是从基址根据偏移找到他们的位置，**从他们的存储方式可以看出，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。

- 大端模式：是指数据的**高字节**保存在内存的**低地址**中，而数据的**低字节**保存在内存的**高地址**中
- 小端模式，是指数据的**高字节**保存在内存的**高地址**中，而数据的**低字节**保存在内存的**低地址**中

（速记：内存地址由低到高，先读到高位地址是大端，先读到地位地址是小端）



## 1 内存中的表示

假如有一个4字节的数据为` **0x12 34 56 78**`（十进制：`305419896`，`0x12`为高字节，`0x78`为低字节），若将其存放于地址` **0x4000 8000**`中，则有：

| 地址方向              | 小端           | 大端           |
| --------------------- | -------------- | -------------- |
| 0x4000 8003（高地址） | 0x12（高字节） | 0x78（低字节） |
| 0x4000 8002           | 0x34           | 0x56           |
| 0x4000 8001           | 0x56           | 0x34           |
| 0x4000 8000（低地址） | 0x78（低字节） | 0x12（高字节） |



同理，`0x1234567`的大端字节序和小端字节序的写法如下图

![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016112201.gif)

## 2 总结

计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。

如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。

理解这一点，才能理解计算机如何处理字节序。



字节序的处理，就是一句话：

**"只有读取的时候，才必须区分字节序，其他情况都不用考虑。"**







# 二、优缺点

## 1 大端模式优点

符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小

## 2 小端模式优点

**1.** 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）；

 **2.** CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效



## 3 现状

- Intel的80×86系列芯片使用小端存储模式
- ARM芯片默认采用小端，但可以切换为大端
- MIPS芯片采用大端，但可以在大小端之间切换
- 在网络上传输的数据普遍采用的都是大端



## 4 常见字节序

一般操作系统都是小端，而通讯协议是大端的。
### 4.1 常见CPU的字节序

Big Endian : PowerPC、IBM、Sun
Little Endian : x86、DEC
ARM既可以工作在大端模式，也可以工作在小端模式。

### 4.2 常见文件的字节序
Adobe PS – Big Endian
BMP – Little Endian
DXF(AutoCAD) – Variable
GIF – Little Endian
JPEG – Big Endian
MacPaint – Big Endian
RTF – Little Endian



## 5 应用

### 1 网络字节序与主机字节序的转换

由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换，下面是 socket 提供的转换函数

### 2 数组在大端小端情况下的存储：

Big-Endian: 低地址存放高位，如下：

高地址

​        buf[3] (0x78) -- 存放数据的低位
​        buf[2] (0x56)
​        buf[1] (0x34)

​		buf[0] (0x12) -- 存放数据的高位

低地址



Little-Endian: 低地址存放低位，如下：

高地址

​        buf[3] (0x12) -- 高位
​        buf[2] (0x34)
​        buf[1] (0x56)

​		buf[0] (0x78) -- 低位

低地址



### 3、转为实际的值

举例来说，处理器读入一个16位整数。如果是大端字节序，就按下面的方式转成值。

```clike
x = buf[offset]<<8 | buf[offset+1];
```

上面代码中，第一个字节左移8位（即后面添8个`0`），然后再与第二个字节进行或运算。



```java
/* 大端字节序 */
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24);

/* 小端字节序 */
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
```





参考：https://blog.csdn.net/ce123_zhouwei/article/details/6971544

https://www.ruanyifeng.com/blog/2016/11/byte-order.html

