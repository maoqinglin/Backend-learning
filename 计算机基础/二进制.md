# 一、原码、反码、补码

## 1. 减法

计算机里面，只有加法器，没有减法器，所有的减法运算，都必须用加法进行。

用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。



## 2  模、补数

在日常生活当中，可以看到很多这样的事情：
把某物体左转 90 度，和右转 270 度，在不考虑圈数的条件下，最终的效果是相同的；
把分针倒拨 20 分钟，和正拨 40 分钟，在不考虑时针的条件下，效果也是相同的；
把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，效果也是相同的；
……。
上述几组数字，有这样的关系：
　　90 + 270 = 360
　　20 + 40 = 60
　　25 + 75 = 100
式中的 360、60 和 100，就是“模”。
式中的 90 和 270、20 和 40，以及 25 和 75，就是一对对“互补”的数字。

知道了“模”，求某个数字的“补数”，就是轻而易举的了：
如果模为 365，数字 120 的补数为：365 - 120 = 245。

用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。
  

**二进制数的模**

前面说过的十进制数 25 和 75，它们是 2 位数的运算，模是 100，即 1 的后面加上 2 个 0。
如果有 3 位数参加运算，模就是 1000，即 1 的后面加上 3 个 0。
这里的 1000，是十进制数的一千，可以写成 10^3，即 10 的 3 次方。
推论：有多少位数参加运算，模就是在 1 的后面加上多少个 0。

对于二进制数字，模也是这样推算。
如果是 3 位二进制数参加运算，模就是 1000，即 1 的后面加上 3 个 0；
那么当 8 位二进制数参加运算，模就是 1 0000 0000，即 1 的后面加上 8 个 0。
16 位二进制数参加运算，模可就大了，是 1 的后面加上 16 个 0。
注意：这里提到的 1、0，都是二进制数。
8 位二进制数的模可以按照十进制写成 2^8，即 256。
16 位数二进制数的模，就是 2^16，按照十进制，它就是 65536。  



对于二进制数字，模也是这样推算。
如果是 3 位二进制数参加运算，模就是 1000，即 1 的后面加上 3 个 0；
那么当 8 位二进制数参加运算，模就是 1 0000 0000，即 1 的后面加上 8 个 0。
16 位二进制数参加运算，模可就大了，是 1 的后面加上 16 个 0。
注意：这里提到的 1、0，都是二进制数。
8 位二进制数的模可以按照十进制写成 2^8，即 256。
16 位数二进制数的模，就是 2^16，按照十进制，它就是 65536。



将负数用补码表示，实际上是实现了一种从[-128, 127]到[0, 255]的映射。如下所示：

```text
+----------------------------+
| 255      -1      11111111  |
| 254      -2      11111110  |
| 253      -3      11111101  |
| 252      -4      11111100  |
| 251      -5      11111011  |
| 246      -10     11110110  |
| 236      -20     11101100  |
| 226      -30     11100010  |
| 216      -40     11011000  |
| 206      -50     11001110  |
| 196      -60     11000100  |
| 186      -70     10111010  |
| 156      -100    10011100  |
| 129      -127    10000001  |
| 128      -128    10000000  |
| 127      127     01111111  |
| 100      100     01100100  |
| 70       70      01000110  |
| 60       60      00111100  |
| 50       50      00110010  |
| 40       40      00101000  |
| 30       30      00011110  |
| 20       20      00010100  |
| 10       10      00001010  |
| 5        5       00000101  |
| 4        4       00000100  |
| 3        3       00000011  |
| 2        2       00000010  |
| 1        1       00000001  |
| 0        0       00000000  |
+----------------------------+
```



## 3. 补码

补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。



 二进制数的补码
求二进制数的补数，目的是往计算机里面存放。
在计算机里面，存放的数字什么的，都称为机器码；那么二进制形式的补数，也就改称为补码了。
一般情况下，都是以 8 位二进制数来讨论补码，少数也有用 16 位数的。

计算时加上正数，是不需要进行求取补数的；只有进行减法（或者加上负数），才需要对减数求补数。
补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。

已知一个数 X，其 8 位字长的补码定义为：

　　　　　　/  X        0 <= X <= +127 ；正数和0的补码，就是该数字本身
 　[X]补 = |
　　　　　　\ 2^8 －|X|     －128 <= X < 0 ；负数的补码，就是用 1 0000 0000，减去该数字的绝对值

例如 X = －126，其补码为 1000 0010，计算方法如下：

　　　　1 0000 0000
　　　－　0111  1110
　－－－－－－－－－－－
　　　　　1000 0010



计算机对带符号数的表示有三种方法：原码、反码和补码。
8位原码和反码能够表示数的范围是-127~127。
**8位补码能够表示数的范围是 -128~127。**
范围是-128~127，那肯定是用补码表示的。 10000000-11111111表示-128到-1， 00000000-01111111表示0-127 补码的1111 1111转换成原码就是1000 0001，也就是-1，补码就是二进制表示负数的一种方法。
引入了补码概念：负数的补码就是对反码加一，而正数不变,正数的原码反码补码是一样的。在补码中用(-128)代替了(-0)，所以补码的表示范围为：(-128~0~127)共256个。
**注意:（-128)没有相对应的原码和反码，(-128) = (10000000)。**
所谓原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。
反码表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
补码表示法规定：正数的补码与其原码相同；负数的补码是在其反码的末位加1。







参考：https://www.douban.com/note/223507364/

https://www.zhihu.com/question/20159860