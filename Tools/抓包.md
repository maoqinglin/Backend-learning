

# 一、基础知识

## 1、**UDP疑难杂症**

### 1.1 **UDP的传输方式：面向报文**

面向报文的传输方式决定了UDP的数据发送方式是一份一份的，也就是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。那么UDP的报文大小由哪些影响因素呢？UDP数据包的理论长度是多少，合适的UDP数据包应该是多少呢？

**(1)UDP报文大小的影响因素，主要有以下3个**

>[1] UDP协议本身，UDP协议中有16位的UDP报文长度，那么UDP报文长度不能超过2^16=65536.
>[2] 以太网(Ethernet)数据帧的长度，数据链路层的MTU(最大传输单元)。
>[3] socket的UDP发送缓存区大小

**(2) UDP数据包最大长度**

根据UDP协议，从UDP数据包的包头可以看出，UDP的最大包长度是2^16-1的个字节。由于UDP包头占8个字节，而在IP层进行封装后的**IP包头占去20字节**，**所以这个是UDP数据包的最大理论长度是2^16 - 1 - 8 - 20 = 65507字节。**如果发送的数据包超过65507字节，send或sendto函数会错误码1(Operation not permitted， Message too long)，当然啦，一个数据包能否发送65507字节，还和UDP发送缓冲区大小（linux下UDP发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，如果发送缓冲区小于65507字节，在发送一个数据包为65507字节的时候，send或sendto函数会错误码1(Operation not permitted， No buffer space available)。

**(3) UDP数据包理想长度**

理论上UDP报文最大长度是65507字节，实际上发送这么大的数据包效果最好吗？我们知道UDP是不可靠的传输协议，为了减少UDP包丢失的风险，我们最好能控制UDP包在下层协议的传输过程中不要被切割。相信大家都知道MTU这个概念。 MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64字节，最大不能超过1518字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网EthernetII最大的数据帧是1518字节，**<span style="color:red">除去以太网帧的帧头（DMAC目的MAC地址48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes</span>**和**帧尾CRC校验部分4Bytes**那么剩下承载上层协议的地方也就是Data域最大就只能有1500字节这个值我们就把它称之为MTU。
理论上UDP报文最大长度是65507字节，实际上发送这么大的数据包效果最好吗？我们知道UDP是不可靠的传输协议，为了减少UDP包丢失的风险，我们最好能控制UDP包在下层协议的传输过程中不要被切割。相信大家都知道MTU这个概念。 MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64字节，最大不能超过1518字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网EthernetII最大的数据帧是1518字节，除去以太网帧的帧头（DMAC目的MAC地址48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500字节这个值我们就把它称之为MTU。
**在下层数据链路层最大传输单元是1500字节的情况下，要想IP层不分包，那么UDP数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = 1472字节。不过鉴于Internet上的标准MTU值为576字节，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在 (576-8-20)548字节以内。**



### 1.2 UDP数据包的发送和接收问题

**(1) UDP的通信有界性**
在阻塞模式下，UDP的通信是以数据包作为界限的，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。

**(2) UDP数据包的无序性和非可靠性**
client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包。





## 2、抓包原理

Linux抓包是通过注册一种虚拟的底层网络协议来完成对网络报文(准确的说是网络设备)消息的处理权。当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议，例如以太网协议、x25协议处理模块来尝试进行报文的解析处理，这一点和一些文件系统的挂载相似，就是让系统中所有的已经注册的文件系统来进行尝试挂载，如果哪一个认为自己可以处理，那么就完成挂载。
当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块。



# 二、WireShark





#  三、tcpdump抓包规则常用命令





```bash
1. 下面的例子全是以抓取eth0接口为例，如果不加”-i eth0”是表示抓取所有的接口包括lo。  

抓取包含172.16.1.122的数据包  
# tcpdump -i eth0 -vnn host 172.16.1.122  
 
抓取包含172.16.1.0/24网段的数据包  
# tcpdump -i eth0 -vnn net 172.16.1.0/24  

抓取包含端口22的数据包  
# tcpdump -i eth0 -vnn port 22  

抓取udp协议的数据包  
# tcpdump -i eth0 -vnn  udp  
   
抓取icmp协议的数据包  
# tcpdump -i eth0 -vnn icmp  

抓取arp协议的数据包  
# tcpdump -i eth0 -vnn arp  

抓取ip协议的数据包  
# tcpdump -i eth0 -vnn ip  

抓取源ip是172.16.1.122数据包。  
# tcpdump -i eth0 -vnn src host 172.16.1.122  

抓取目的ip是172.16.1.122数据包  
# tcpdump -i eth0 -vnn dst host 172.16.1.122  

抓取源端口是22的数据包  
# tcpdump -i eth0 -vnn src port 22  

抓取源ip是172.16.1.253且目的ip是22的数据包  
# tcpdump -i eth0 -vnn src host 172.16.1.253 and dst port 22  
                
抓取源ip是172.16.1.122或者包含端口是22的数据包  
# tcpdump -i eth0 -vnn src host 172.16.1.122 or port 22  

抓取源ip是172.16.1.122且端口不是22的数据包  
# tcpdump -i eth0 -vnn src host 172.16.1.122 and not port 22  

抓取源ip是172.16.1.59且目的端口是22，或源ip是172.16.1.68且目的端口是80的数据包。  
# tcpdump -i  eth0 -vnn 'src host 172.16.1.59 and dst port 22' or  ' src host 172.16.1.68 and dst port 80 '  

把抓取的数据包记录存到/tmp/fill文件中，当抓取100个数据包后就退出程序。  
# tcpdump –i eth0 -vnn -w  /tmp/fil1 -c 100  

从/tmp/fill记录中读取tcp协议的数据包  
# tcpdump –i eth0 -vnn -r  /tmp/fil1 tcp  

从/tmp/fill记录中读取包含172.16.1.58的数据包  
# tcpdump –i eth0 -vnn -r  /tmp/fil1 host  172.16.1.58  
```





首选介绍一下tcpdump的常用参数

tcpdump采用命令行方式，它的命令格式为：
　　tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ]
　　　　　　　　　　[ -i 网络接口 ] [ -r 文件名] [ -s snaplen ]
　　　　　　　　　　[ -T 类型 ] [ -w 文件名 ] [表达式 ]

 tcpdump的选项介绍

```bash
	 -a 　　　将网络地址和广播地址转变成名字；
　　　-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；
　　　-dd 　　　将匹配信息包的代码以[C语言](http://lib.csdn.net/base/c)程序段的格式给出；
　　　-ddd 　　　将匹配信息包的代码以十进制的形式给出；
　　　-e 　　　在输出行打印出数据链路层的头部信息；
　　　-f 　　　将外部的Internet地址以数字的形式打印出来；
　　　-l 　　　使标准输出变为缓冲行形式；
　　　-n 　　　不把网络地址转换成名字；
　　　-t 　　　在输出的每一行不打印时间戳；
　　　-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；
　　　-vv 　　　输出详细的报文信息；
　　　-c 　　　在收到指定的包的数目后，tcpdump就会停止；
　　　-F 　　　从指定的文件中读取表达式,忽略其它的表达式；
　　　-i 　　　指定监听的网络接口；
　　　-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；
　　　-w 　　　直接将包写入文件中，并不分析和打印出来；
　　　-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc（远程过程
          调用）和snmp（简单网络管理协议；）
```

当网络出现故障时，由于直接用tcpdump抓包分析有点困难，而且当网络中数据比较多时更不容易分析，使用tcpdump的-w参数+ethereal分析会很好的解决这个问题，具体参数如下：

tcpdump -i eth1 -c 2000 -w eth1.cap

-i eth1 只抓eth1口的数据

-c 2000代表数据包的个数，也就是只抓2000个数据包

-w eth1.cap 保存成cap文件，方便用ethereal分析

抓完数据包后ftp到你的FTP服务器，put一下，然后用ethereal软件打开就可以很直观的分析了

注：有时将.cap文件上传到FTP服务器后，发现用ethreal打开时提示数据包大于65535个，这是你在ftp上传或者下载的时候没有用bin的模式上传的原因。

另：有的网站提示在tcpdump中用-s 0命令，例如 tcpdump -i eth1 -c 2000 -s0 -w eth1.cap，可实际运行该命令时系统却提示无效的参数,去掉-s 0参数即可

例子：

[root@localhost cdr]#tcpdump -i eth0 -t tcp -s 60000 -w diaoxian.cap 
[root@localhost cdr]# tcpdump host 58.240.72.195 -s 60000 -w x.cap



```bash
tcpdump 的抓包保存到文件的命令参数是-w xxx.cap
抓eth1的包 
tcpdump -i eth1 -w /tmp/xxx.cap 

抓 192.168.1.123的包 
tcpdump -i eth1 host 192.168.1.123 -w /tmp/xxx.cap 

抓192.168.1.123的80端口的包 
tcpdump -i eth1 host 192.168.1.123 and port 80 -w /tmp/xxx.cap 

抓192.168.1.123的icmp的包 
tcpdump -i eth1 host 192.168.1.123 and icmp -w /tmp/xxx.cap 

抓192.168.1.123的80端口和110和25以外的其他端口的包 
tcpdump -i eth1 host 192.168.1.123 and ! port 80 and ! port 25 and ! port 110 -w /tmp/xxx.cap 

抓vlan 1的包 
tcpdump -i eth1 port 80 and vlan 1 -w /tmp/xxx.cap 

抓pppoe的密码 
tcpdump -i eth1 pppoes -w /tmp/xxx.cap 

以100m大小分割保存文件， 超过100m另开一个文件 -C 100m 

抓10000个包后退出 -c 10000 

后台抓包， 控制台退出也不会影响： 
nohup tcpdump -i eth1 port 110 -w /tmp/xxx.cap & 
抓下来的文件可以直接用ethereal 或者wireshark打开。 wireshark就是新版的ethereal，程序换名了
```



# 四、常见问题

1、网卡工作在哪一层

**网卡工作在物理层和数据链路层的MAC子层**

2、网络驱动程序的数据发送和接收

中断方式利用硬件体系结构的中断机制实现设备和系统的应答对话，即当物理设备需要CPU处理数据时，就向CPU发送一个终端信号，系统则在收到信号后调用相应的中断服务程序响应对设备中断的处理。因此，基本在所有的网络设备驱动程序中都是用中断方式的。

每一个网卡上都有一块FIFO存储器，对于NIC（Network Interface Controller），FIFO存储器是用来通过系统总线传送数据到系统存储器之前，缓存从LAN上接收到的数据。对与快速以太网还有一个直接内存存取（DMA：Directly Memory Access）控制器，用于提供对系统存储器的可靠访问。

驱动为网卡分配一个环形缓冲区，在一段连续的物理内存中实现。

1、  数据接收

（1）       接收来自MAC的数据包，先暂存于片内FIFO接收队列；

（2）       当接收器达到早期接收上线时就移至环形缓冲区；

（3）       待整个数据包全部从FIFO移至缓存后，将接收状态寄存器和包长度写入接收的数据包头部，并更新CBA（Current Buffer Address）寄存器的值；

（4）       CMD（Command）寄存器中的BufferEmpty位和ISR（中断状态寄存器）寄存器的ROK位置1，并发出ROK的中断；

（5）       ISR中断调用完成后，清除ISR（ROK）并更新CAPR（Current Address of Packet Read，指向接收缓存的已读取包的地址），完成本次接收。

2、  数据发送

（1）       将待传送的数据写入主存中一段连续的缓存空间，由OS配合驱动程序完成；

（2）       找到一个可用的描述器，并写入内容，包括该数据包的开始物理地址和传输状态字（包的大小、可传送下限、OWN位）；

（3）       OWN位有效，将数据从缓存移至片内FIFO队列；

（4）       当FIFO队列中的数据达到早期传送下限，NIC的传送单元就会启动，将数据顺序输出至线路；

（5）       当整个数据包都已经传至FIFO，OWN位置1；

（6）       当整个数据包都已经传至线路上， TOK寄存器置1；

（7）       当TOK（IMR）和TOK（ISR）多置1，就发出TOK中断；

（8）       TOK中断调用完成以后，清除TSD状态字，完成本次传送。

 

可以看出，网卡需要发送/接收数据，都必须以中断的方式告诉系统，系统处理中断后做出相应操作。

网卡存在一定大小的FIFO存储器，同时还有缓冲区，缓冲区是由系统以及驱动共同分配一段连续的物理内存，所有的发送/接收的数据，都必须通过FIFO已经缓冲区，只有一包数据都发送成功后，才能继续发送下一包数据。系统维护缓冲区，只有当缓冲区有空间时才会接受上层来的数据，而网卡处理数据的速率远高于接收数据的最大速率，因此在网卡上不会存在堵塞情况。

对编程而言，在应用层调用传输层函数send/sendto，使用套接字传送数据，屏蔽了底层的所有实现。此时，send/sendto函数是没有阻塞的，只要调用，必然有返回值，成功返回发送数据的长度，失败则返回负值（失败的主要原因是网络连接的问题），因此可能存在数据丢失的现象，需要写程序的时候保证数据的传输成功。但是只有send/sendto函数返回后，程序才会执行下一次发送，因此编程时没必要考虑数据会在传输层上出现阻塞。