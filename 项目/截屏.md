## 1、截屏

```java
public class RecordUtil {

    private static final String TAG = "screenshot";
    private static final String CHANNEL_ID = "channel_id";
    private static final String CHANNEL_NAME = "channel_much";
    private static final String PATH = Environment.getExternalStorageDirectory().getPath() + "/Gif/";
    private static final String GIF_FILE_NAME_TEMPLATE = "Gif_%s.gif";
    private static final String GIF_SHARE_SUBJECT_TEMPLATE = "Gif (%s)";
    private static final ExecutorService sCachedThreadPool = Executors.newCachedThreadPool();
    private static ScheduledExecutorService sScheduledThreadPool;
    private static final String SCREENSHOT_URI_ID = "android:screenshot_uri_id";
    private static SparseArray<Bitmap> sScreenshotSparseArray = new SparseArray<>();
    private static int sScreenshotKey = 0;

    private static int sDelay = 200;
    private static int sScale = 4;

    public static void start(final Context context) {
        sScreenshotSparseArray.clear();
        sScreenshotKey = 0;
        /**
         * author: chenhb
         * description: open show the touche point position during gif recording
         * updateTime: 2018.7.16
         */
        Settings.System.putInt(context.getContentResolver(), "show_touches", 1);
        boolean isAutoRotate = Settings.System.getInt(context.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) == 1;
        Log.d(TAG, "===== start: isAutoRotate = " + isAutoRotate + " =====");
        SCApplication.IS_AUTOROTATE = isAutoRotate;
        // 关闭自动旋转
        if (isAutoRotate) {
            Display d = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
            Settings.System.putInt(context.getContentResolver(), Settings.System.USER_ROTATION, d.getRotation());
            Settings.System.putInt(context.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0);
        }

        // 读取用户设置
        final String fps = PreferenceManager.getDefaultSharedPreferences(context).getString("fps", "0");
        if ("0".equals(fps)) {
            sDelay = 200;
        } else if ("1".equals(fps)) {
            sDelay = 125;
        } else if ("2".equals(fps)) {
            sDelay = 100;
        }
        String resolution = PreferenceManager.getDefaultSharedPreferences(context).getString("resolution", "0");
        if ("0".equals(resolution)) {
            sScale = 4;
        } else if ("1".equals(resolution)) {
            sScale = 3;
        } else if ("2".equals(resolution)) {
            sScale = 2;
        }
        Log.d(TAG, "fps = " + fps + ", resolution = " + resolution);

        // 抽出多次截图使用的共同代码，不反复执行
        Matrix matrix = new Matrix();
        WindowManager windowManager = (WindowManager) context.getSystemService(WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();
        DisplayMetrics metrics = SCApplication.DISPLAY_METRICS;
        final float[] dims = {metrics.widthPixels, metrics.heightPixels};
        final float degrees = getDegreesForRotation(display.getRotation());
        final boolean requiresRotation = (degrees > 0);
        if (requiresRotation) {
            // Get the dimensions of the device in its native orientation
            matrix.reset();
            matrix.preRotate(-degrees);
            matrix.mapPoints(dims);
            dims[0] = Math.abs(dims[0]);
            dims[1] = Math.abs(dims[1]);
        }
        final String userName = BitmapUtil.getUserName(context);
        // 每隔sDelay截一张图
        sScheduledThreadPool = Executors.newScheduledThreadPool(1);
        sScheduledThreadPool.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                sCachedThreadPool.execute(new Runnable() {
                    @Override
                    public void run() {
                        long start = System.currentTimeMillis();
                        int curKey = sScreenshotKey++;
                        Bitmap screenBitmap = getFrame(context, dims, degrees, requiresRotation, userName);
                        if (screenBitmap != null) {
                            Log.d(TAG, "getFrame: use " + (System.currentTimeMillis() - start) + "ms, put to " + curKey);
                            sScreenshotSparseArray.put(curKey, screenBitmap);
                        }
                    }
                });
            }
        }, 0, sDelay, TimeUnit.MILLISECONDS);
    }

    public static void stop(final Context context, final GifWindowService.CallBack callBack) {
        if (SCApplication.IS_AUTOROTATE) {
            // 恢复自动转屏
            Settings.System.putInt(context.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 1);
        }
        /**
         * author: chenhb
         * description: close show the touche point position during gif recording
         * updateTime: 2018.7.16
         */
        Settings.System.putInt(context.getContentResolver(), "show_touches", 0);
        Log.d(TAG, "=====stop: " + sScreenshotSparseArray.size() + "=====");
        sScheduledThreadPool.shutdown();
        sCachedThreadPool.execute(new Runnable() {
            @Override
            public void run() {
                String gifDate = new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date());
                String gifFileName = String.format(GIF_FILE_NAME_TEMPLATE, gifDate);
                try {
                    String filePath = createGif(gifFileName, sScreenshotSparseArray, callBack);
                    storeMedia(context, filePath);
//                    new MediaScanner(context).scanFile(filePath, MimeTypeMap.getSingleton().getMimeTypeFromExtension("gif"));
                } catch (IOException e) {
                    Log.e(TAG, "doInBackground: ", e);
                    e.printStackTrace();
                }
            }

        });
    }

    private static Bitmap getFrame(Context context, float[] dims, float degrees, boolean requiresRotation, String userName) {
        if (sScheduledThreadPool.isShutdown()) {
            Log.d(TAG, "interrupt: sScheduledThreadPool isShutdown");
            return null;
        }
        long start = System.currentTimeMillis();

        // 1. 截图
        Bitmap screenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]);
        Log.d(TAG, "  screenshot: use " + (System.currentTimeMillis() - start) + "ms");
        start = System.currentTimeMillis();
        if (screenBitmap == null) {
            Log.d(TAG, "interrupt: screenBitmap is null");
            return null;
        }
        if (sScheduledThreadPool.isShutdown()) {
            Log.d(TAG, "interrupt: sScheduledThreadPool isShutdown");
            return null;
        }

        // 2. copy (截图返回的bitmap直接使用openCV会出现花屏)
        Bitmap copy = screenBitmap.copy(Bitmap.Config.RGB_565, false);
        screenBitmap.recycle();
        screenBitmap = copy;
        Log.d(TAG, "  copy: use " + (System.currentTimeMillis() - start) + "ms");

        // 3. 缩小
        screenBitmap = BitmapUtil.resize(screenBitmap, screenBitmap.getWidth() / sScale, screenBitmap.getHeight() / sScale);

        // 4. 旋转
        Bitmap ss = Bitmap.createBitmap(SCApplication.DISPLAY_METRICS.widthPixels / sScale,
                SCApplication.DISPLAY_METRICS.heightPixels / sScale, Bitmap.Config.RGB_565);
        Canvas c = new Canvas(ss);
        c.save();
        if (requiresRotation) {
            // Rotate the screenshot to the current orientation
            c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
            c.rotate(degrees);
            c.translate(-dims[0] / 2 / sScale, -dims[1] / 2 / sScale);
        }
        c.drawBitmap(screenBitmap, 0, 0, null);
        c.restore();

        // 5. 加水印
        if (sScheduledThreadPool.isShutdown()) {
            Log.d(TAG, "interrupt: sScheduledThreadPool isShutdown");
            return null;
        }
        BitmapUtil.addWaterMark(context, c, sScale, userName);
        c.setBitmap(null);

        // Recycle the previous bitmap
        screenBitmap.recycle();
        screenBitmap = ss;

        // Optimizations
        screenBitmap.setHasAlpha(false);

        return screenBitmap;
    }

    private static float getDegreesForRotation(int value) {
        switch (value) {
            case Surface.ROTATION_90:
                return 360f - 90f;
            case Surface.ROTATION_180:
                return 360f - 180f;
            case Surface.ROTATION_270:
                return 360f - 270f;
        }
        return 0f;
    }

    private static String createGif(String filename, SparseArray<Bitmap> bitmaps, GifWindowService.CallBack callBack) throws IOException {
        if (bitmaps.size() == 0) {
            callBack.onProgressChanged(100);
            return null;
        }
        long startTime = System.currentTimeMillis();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        AnimatedGifEncoder gifEncoder = new AnimatedGifEncoder();
        gifEncoder.start(baos);
        gifEncoder.setRepeat(0); // 0 means play indefinitely
        gifEncoder.setDelay(sDelay);
        int size = bitmaps.size();
        if (size > 0) {
            for (int i = 0; i < size; i++) {
                Bitmap bitmap = bitmaps.get(i);
                if (bitmap == null) {
                    Log.d(TAG, "createGif: bitmap is null on " + (i+1));
                    // 丢弃该帧
                    continue;
                }
                boolean b = gifEncoder.addFrame(bitmap);
                bitmap.recycle();
                // 计算进度
                Log.d(TAG, "createGif: addFrame " + (i + 1) + "/" + size + ", " + b);
                callBack.onProgressChanged((i + 1) * 100 / size);
            }
        }
        // 回收stop后多出来的bitmap
        if (bitmaps.size() > size) {
            int residue = bitmaps.size() - size;
            Log.d(TAG, "createGif: recycle residue: " + residue);
            for (int i = 0; i < residue; i++) {
                Bitmap item = bitmaps.get(bitmaps.size() - 1 - i);
                if (item.isRecycled()) {
                    Log.d(TAG, "createGif: isRecycled = " + item);
                    continue;
                }
                item.recycle();
                Log.d(TAG, "createGif: recycle " + item);
            }
        }
        bitmaps.clear();
        gifEncoder.finish(); //finish
        Log.d(TAG, "createGif: finish! use " + (System.currentTimeMillis() - startTime) + "ms");

        File file = new File(PATH);
        if (!file.exists()) file.mkdir();
        String path = PATH + filename;
        FileOutputStream fos = new FileOutputStream(path);
        baos.writeTo(fos);
        baos.flush();
        fos.flush();
        baos.close();
        fos.close();
        BitmapUtil.removeWatermarkCache();
        return path;
    }

    private static void storeMedia(Context context, String filePath) {
        // Save the screenshot to the MediaStore
        ContentValues values = new ContentValues();
        ContentResolver resolver = context.getContentResolver();
        values.put(MediaStore.Images.ImageColumns.DATA, filePath);
        values.put(MediaStore.Images.ImageColumns.MIME_TYPE, "image/gif");
        String pkgName = RecordUtil.getAppPkgName(context);
        String appName = RecordUtil.getAppName(context, pkgName);
        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(System.currentTimeMillis()));
        String subject = String.format(GIF_SHARE_SUBJECT_TEMPLATE, subjectDate);
        values.put(MediaStore.Images.ImageColumns.DESCRIPTION, pkgName + "," + appName);
        Uri uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
        Bitmap picture = BitmapFactory.decodeFile(filePath);
        //show gif notifycation
        showGifNotifycation(context, subject, uri, picture);
    }

    private static void showGifNotifycation(Context context, String subject, Uri uri, Bitmap picture) {
        NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
        final long now = System.currentTimeMillis();
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_LOW);
            mNotificationManager.createNotificationChannel(channel);
        }
        // Setup the notification
        Notification.BigPictureStyle mNotificationStyle = new Notification.BigPictureStyle()
                .bigPicture(ReflectUtil.createAshmemBitmap(picture));

        // The public notification will show similar info but with the actual screenshot omitted
        Notification.Builder builder;
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            builder = new Notification.Builder(context, CHANNEL_ID);
        }else {
            builder = new Notification.Builder(context);
        }
        // Create the intent to show the screenshot in gallery
        Intent launchIntent = new Intent(Intent.ACTION_VIEW);
        launchIntent.setDataAndType(uri, "image/png");
        launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        Notification.Builder mPublicNotificationBuilder = builder
                .setContentTitle(context.getString(R.string.screenshot_saved_title))
                .setContentText(context.getString(R.string.screenshot_saved_text))
                .setContentIntent(PendingIntent.getActivity(context, 0, launchIntent, 0))
                .setSmallIcon(R.drawable.stat_notify_image)
                .setCategory(Notification.CATEGORY_PROGRESS)
                .setWhen(now)
                .setAutoCancel(true)
                .setShowWhen(true)
                .setColor(context.getColor(Resources.getSystem().getIdentifier("system_notification_accent_color", "color", "android")));
        SCApplication.overrideNotificationAppName(context, mPublicNotificationBuilder);
        Notification.Builder newbuilder;
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            newbuilder = new Notification.Builder(context, CHANNEL_ID);
        }else {
            newbuilder = new Notification.Builder(context);
        }
        Notification.Builder mNotificationBuilder = newbuilder
                .setContentTitle(context.getString(R.string.screenshot_saved_title))
                .setContentText(context.getString(R.string.screenshot_saved_text))
                .setSmallIcon(R.drawable.stat_notify_image)
                .setContentIntent(PendingIntent.getActivity(context, 0, launchIntent, 0))
                .setWhen(now)
                .setShowWhen(true)
                .setColor(context.getColor(Resources.getSystem().getIdentifier("system_notification_accent_color", "color", "android")))
                .setStyle(mNotificationStyle)
                .setAutoCancel(true)
                .setPublicVersion(mPublicNotificationBuilder.build());
        ReflectUtil.setFlag(mNotificationBuilder, Notification.FLAG_NO_CLEAR, false);
        SCApplication.overrideNotificationAppName(context, mNotificationBuilder);

        Intent sharingIntent = new Intent(Intent.ACTION_SEND);
        sharingIntent.setType("image/png");
        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);
        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);

        // Create a share action for the notification
        PendingIntent chooseAction = PendingIntent.getBroadcast(context, 0,
                new Intent(context, GlobalScreenshot.TargetChosenReceiver.class),
                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
        Intent chooserIntent = Intent.createChooser(sharingIntent, null,
                chooseAction.getIntentSender())
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        PendingIntent shareAction = PendingIntent.getActivity(context, 0, chooserIntent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        Notification.Action.Builder shareActionBuilder = new Notification.Action.Builder(
                R.drawable.ic_screenshot_share,
                context.getString(Resources.getSystem().getIdentifier("share", "string", "android")), shareAction);
        mNotificationBuilder.addAction(shareActionBuilder.build());

        // Create a delete action for the notification
        PendingIntent deleteAction = PendingIntent.getBroadcast(context, 0,
                new Intent(context, GlobalScreenshot.DeleteScreenshotReceiver.class)
                        .putExtra(SCREENSHOT_URI_ID, uri.toString()),
                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
        Notification.Action.Builder deleteActionBuilder = new Notification.Action.Builder(
                R.drawable.ic_screenshot_delete,
                context.getString(Resources.getSystem().getIdentifier("delete", "string", "android")), deleteAction);
        mNotificationBuilder.addAction(deleteActionBuilder.build());

        mNotificationBuilder.setLargeIcon(ReflectUtil.createAshmemBitmap(picture));
        mNotificationStyle.bigLargeIcon((Bitmap) null);
        mNotificationManager.notify(R.id.notification_screenshot, mNotificationBuilder.build());
    }

    public static String getAppPkgName(Context context) {
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(1);
        if (runningTasks == null || runningTasks.isEmpty()) {
            return null;
        }
        return runningTasks.get(0).topActivity.getPackageName();
    }


    public static String getAppName(Context context, String pkgName) {
        if (pkgName == null) {
            return null;
        }
        String appName = null;
        PackageManager pm = context.getPackageManager();
        try {
            ApplicationInfo applicationInfo = pm.getApplicationInfo(pkgName, PackageManager.GET_META_DATA);
            appName = pm.getApplicationLabel(applicationInfo).toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return appName;
    }
}
```

```java
/**
 * 编译用的隐藏类，只声明方法
 */

public class SurfaceControl {
    public static Bitmap screenshot(int width, int height) {
        return null;
    }
}
```



```java
public class ScreenshotController {

    private static final String TAG = "screenshot";
    private final Object mScreenshotLock = new Object();
    private ServiceConnection mScreenshotConnection = null;
    private Handler mHandler;
    private static ScreenshotController sInstance;
    private static final int HIDE = 104;
    private boolean isBound = false;
    private Context mContext;
    private GifListener mGifListener;

    public static ScreenshotController getInstance(Context context, Handler handler) {
        if (sInstance == null) {
            sInstance = new ScreenshotController(context, handler);
        }
        return sInstance;
    }

    private ScreenshotController(Context context, Handler handler) {
        this.mContext = context;
        this.mHandler = handler;
    }

    public void setHandler(Handler handler){
        this.mHandler = handler;
    }

    public void takeScreenshot() {
        synchronized (mScreenshotLock) {
            if (mScreenshotConnection != null) {
                // 上一次截图还没处理完
                return;
            }
            // 暂时隐藏悬浮窗2秒
//            if (mHandler.hasMessages(HIDE)) {
                Log.d(TAG, "有 HIDE msg");
                mHandler.sendEmptyMessage(HIDE);
                SystemClock.sleep(50);
//            }

            final ComponentName serviceComponent = new ComponentName(mContext, TakeScreenshotService.class);
            final Intent serviceIntent = new Intent();
            serviceIntent.setComponent(serviceComponent);
            ServiceConnection conn = new ServiceConnection() {
                @Override
                public void onServiceConnected(ComponentName name, IBinder service) {
                    synchronized (mScreenshotLock) {
                        if (mScreenshotConnection != this) {
                            return;
                        }
                        Messenger messenger = new Messenger(service);
                        Message msg = Message.obtain(null, TakeScreenshotService.TAKE_SCREENSHOT_FULLSCREEN);
                        final ServiceConnection myConn = this;
                        Handler h = new Handler(mHandler.getLooper()) {
                            @Override
                            public void handleMessage(Message msg) {
                                synchronized (mScreenshotLock) {
                                    if (mScreenshotConnection != null
                                            && mScreenshotConnection == myConn) {
                                        if (isBound) {
                                            mContext.unbindService(mScreenshotConnection);
                                            isBound = false;
                                        }
                                        mScreenshotConnection = null;
                                        mHandler.removeCallbacks(mScreenshotTimeout);
                                    }
                                }
                            }
                        };
                        msg.replyTo = new Messenger(h);
                        msg.arg1 = msg.arg2 = 0;
                        boolean statusBarVisible = true;
                        boolean navBarVisible = true;
//                        if (mStatusBar != null && mStatusBar.isVisibleLw())
                        if (statusBarVisible)
                            msg.arg1 = 1;
//                        if (mNavigationBar != null && mNavigationBar.isVisibleLw())
                        if (navBarVisible)
                            msg.arg2 = 1;
                        try {
                            messenger.send(msg);
                        } catch (RemoteException e) {
                        }
                    }
                }

                @Override
                public void onServiceDisconnected(ComponentName name) {
                    synchronized (mScreenshotLock) {
                        if (mScreenshotConnection != null) {
                            if (isBound) {
                                mContext.unbindService(mScreenshotConnection);
                                isBound = false;
                            }
                            mScreenshotConnection = null;
                            mHandler.removeCallbacks(mScreenshotTimeout);
                            notifyScreenshotError();
                        }
                    }
                }
            };
            try {
                if (mContext.bindService(serviceIntent, conn, Context.BIND_AUTO_CREATE)) {
                    isBound = true;
                    mScreenshotConnection = conn;
                    mHandler.postDelayed(mScreenshotTimeout, 10000);
                }
            }catch (Exception e){
                //do nothing
            }

        }
    }

    /**
     * Notifies the screenshot service to show an error.
     */
    void notifyScreenshotError() {
        // If the service process is killed, then ask it to clean up after itself
        // Show a message that we've failed to save the image to disk
        NotificationManager nm = (NotificationManager)
                mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        GlobalScreenshot.notifyScreenshotError(mContext, nm,
                R.string.screenshot_failed_to_save_unknown_text);
    }

    private final Runnable mScreenshotTimeout = new Runnable() {
        @Override
        public void run() {
            synchronized (mScreenshotLock) {
                if (mScreenshotConnection != null) {
                    if (isBound) {
                        mContext.unbindService(mScreenshotConnection);
                        isBound = false;
                    }
                    mScreenshotConnection = null;
                    notifyScreenshotError();
                }
            }
        }
    };

    public void setGifListener(GifListener gifListener){
        this.mGifListener = gifListener;
    }

    public void performClickButton(){
        if(mGifListener != null){
            mGifListener.clickButton();
        }
    }

    public interface GifListener{
        void clickButton();
    }

}

```



## 2、内录功能

```java
/**
     * add by linmq 2019-4-24 启动Activity获取创建MediaProjection的intent
     */
private void doInnerRecord() {
    if (mProjectionIntent != null) {
        startRecordByIntent(mProjectionIntent);
    } else {
        Intent recordIntent = new Intent(this, RecordActivity.class);
        recordIntent.setPackage(this.getPackageName());
        recordIntent.setAction(ACTION_INNER_RECORD);
        startActivity(recordIntent);
    }
}

private void startRecordByIntent(Intent projectionIntent) {
    mRecordController.start(projectionIntent, new ProjectionCallback() {
        @Override
        public void fail() {
            mProjectionIntent = null; // 说明intent已经不合法，必须重新获取
            doInnerRecord();
        }
    });
}
```

```java
public class RecordActivity extends Activity {

    private static final String TAG = "RecordActivity";
    final int REQUSET_VIDEO = 10;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (getMode() != Constant.TYPE_RECORD) {
            return;
        }

        init();
        startRecord();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        startRecord();
    }

    private void init() {
        Window window = getWindow();
        window.setGravity(Gravity.LEFT | Gravity.TOP);
        WindowManager.LayoutParams layoutParams = window.getAttributes();
        layoutParams.x = 0;
        layoutParams.y = 0;
        layoutParams.width = 1;
        layoutParams.height = 1;
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;
        window.setAttributes(layoutParams);
    }

    private int getMode() {
        return PreferenceManager.getDefaultSharedPreferences(this).
                getInt(Constant.MUCH_SHOW_TYPE, Constant.TYPE_RECORD);
    }


    private void startRecord() {
        //获取MediaProjectionManager ，通过这个类 申请权限，
        // 录屏是一个危险的权限，所以每次录屏的时候都得这么申请，用户同意了才行
        MediaProjectionManager projectionManager = (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);
        //开启activity 然后在onActivityResult回调里面判断 用户是否同意录屏权限

        startActivityForResult(projectionManager.createScreenCaptureIntent(), REQUSET_VIDEO);
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        Log.w(TAG, "onActivityResult requestCode=" + requestCode + " resultCode=" + resultCode);
        if (requestCode == REQUSET_VIDEO && resultCode == RESULT_OK) {
            Intent intent = new Intent();
            intent.putExtra(KEY_PROJECTION_INTENT, data);
            intent.setClass(this, GifWindowService.class);
            startService(intent);
        }
    }

}

```

```java
package com.ireadygo.app.screencapture.record;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.media.MediaCodecInfo;
import android.media.MediaMetadataRetriever;
import android.media.projection.MediaProjection;
import android.media.projection.MediaProjectionManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.preference.PreferenceManager;
import android.provider.MediaStore;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;
import android.widget.Toast;

import com.ireadygo.app.screencapture.GifWindowService;
import com.ireadygo.app.screencapture.GlobalScreenshot;
import com.ireadygo.app.screencapture.R;
import com.ireadygo.app.screencapture.SCApplication;
import com.ireadygo.app.screencapture.data.Constant;
import com.ireadygo.app.screencapture.record.model.MediaQualityItem;
import com.ireadygo.app.screencapture.record.refactor.AudioEncodeConfig;
import com.ireadygo.app.screencapture.record.refactor.ScreenRecorder;
import com.ireadygo.app.screencapture.record.refactor.VideoEncodeConfig;
import com.ireadygo.app.screencapture.utils.FileUtil;
import com.ireadygo.app.screencapture.utils.RecordUtil;
import com.ireadygo.app.screencapture.utils.ReflectUtil;

import java.io.File;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import static android.content.Context.MEDIA_PROJECTION_SERVICE;
import static android.content.Context.WINDOW_SERVICE;
import static com.ireadygo.app.screencapture.data.Constant.AUDIO_AAC;
import static com.ireadygo.app.screencapture.data.Constant.KEY_MEDIA_RECORD_PATH;
import static com.ireadygo.app.screencapture.data.Constant.VIDEO_AVC;

public class RecordController {

    private static final String TAG = "RecordController";

    private static RecordController sInstance;
    private Context mContext;
    private MediaProjectionManager mProjectionManager;
    private List<MediaQualityItem> mList = new ArrayList<MediaQualityItem>();

    private ScreenRecorder mRecorder;
    GifWindowService.ProjectionCallback mProjectionCallback;

    private static final int MSG_RECORD_TIME_OUT = 1;
    private static final int MSG_RECORD_FIAL = 2;
    private static final int MSG_RECORD_STOP = 3;
    private static final int MSG_STORE_MEDIA = 4;

    @SuppressLint("HandlerLeak")
    private Handler mainHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case MSG_RECORD_TIME_OUT:
                case MSG_RECORD_STOP:
                    Log.i(TAG, "MSG_RECORD_TIME_OUT stopRecord");
                    stopRecorder();
                    break;
                case MSG_RECORD_FIAL:
                    Toast.makeText(mContext, "record fail", Toast.LENGTH_LONG).show();
                    break;
                case MSG_STORE_MEDIA:
                    Bundle bundle = msg.getData();
                    storeMedia(mContext, bundle.getString(KEY_MEDIA_RECORD_PATH));
                    break;
            }
        }
    };

    public static RecordController getInstance(Context context) {
        if (sInstance == null) {
            synchronized (RecordController.class) {
                if (sInstance == null) {
                    sInstance = new RecordController(context);
                }
            }
        }
        return sInstance;
    }

    private RecordController(Context context) {
        mContext = context;
        mProjectionManager = (MediaProjectionManager) mContext.getSystemService(MEDIA_PROJECTION_SERVICE);
    }

    public void initQualityList() {
        mList.clear();
        mList.add(new MediaQualityItem(0, 60, 10 * 1024 * 1024, 128 * 1024));
        mList.add(new MediaQualityItem(1, 60, 6 * 1024 * 1024, 128 * 1024));
        mList.add(new MediaQualityItem(2, 30, 4 * 1024 * 1024, 128 * 1024));
    }

    private VideoEncodeConfig createVideoConfig(MediaQualityItem mediaQualityItem) {
        final String codec = "OMX.qcom.video.encoder.avc";  // 高通视频编码器
        // video size
        Point realSize = getSelectedWithHeight();
        int width = realSize.x;
        int height = realSize.y;
        int framerate = mediaQualityItem.getFrameRate();
        int iframe = 1;
        int bitrate = mediaQualityItem.getVideoBitRate();
//        MediaCodecInfo.CodecProfileLevel profileLevel = getSelectedProfileLevel();
        return new VideoEncodeConfig(width, height, bitrate,
                framerate, iframe, codec, VIDEO_AVC, null);
    }

    private Point getSelectedWithHeight() {
        WindowManager windowManager = (WindowManager) mContext.getSystemService(WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();
        Point point = new Point();
        display.getRealSize(point);
        return point;
    }

    private AudioEncodeConfig createAudioConfig(MediaQualityItem mediaQualityItem) {
        String codec = "OMX.google.aac.encoder";
        int bitrate = mediaQualityItem.getAudioBitRate();
        int samplerate = 44100; // 取样率
        int channelCount = 1;
        int profile = MediaCodecInfo.CodecProfileLevel.AACObjectMain;

        return new AudioEncodeConfig(codec, AUDIO_AAC, bitrate, samplerate, channelCount, profile);
    }

    public void start(Intent projectionIntent, GifWindowService.ProjectionCallback projectionCallback) {

        if (projectionIntent == null) {
            Log.w(TAG, "start projectionIntent = " + projectionIntent);
            return;
        }
        MediaQualityItem mediaQualityItem = getMeiaQualityItem();

        if (mediaQualityItem != null) {
            MediaProjection projection = null;
            try {
                // Cannot start already started MediaProjection 可能会报错
                projection = mProjectionManager.getMediaProjection(-1, projectionIntent);
                if (projection != null) {
                    //注意格式  创建录制的文件
                    VideoEncodeConfig video = createVideoConfig(mediaQualityItem);
                    AudioEncodeConfig audio = createAudioConfig(mediaQualityItem); // audio can be null
                    if (video == null) {
                        Log.w(TAG, "Create ScreenRecorder failure");
                        projection.stop();
                        return;
                    }

                    mRecorder = newRecorder(projection, video, audio, FileUtil.generateFile());
                    startRecorder();
                } else {
                    Log.e(TAG, "projection is null");
                }
            } catch (IllegalStateException e) {
                if (projectionCallback != null) {
                    projectionCallback.fail();
                }
                Log.e(TAG, "start e: " + e.getMessage());
            }
        }
    }

    private ScreenRecorder newRecorder(MediaProjection mediaProjection, VideoEncodeConfig video,
                                       AudioEncodeConfig audio, File output) {
        ScreenRecorder r = new ScreenRecorder(video, audio,
                1, mediaProjection, output.getAbsolutePath());
        r.setCallback(new ScreenRecorder.Callback() {
            @Override
            public void onStop(Throwable error) {
                mainHandler.sendEmptyMessage(MSG_RECORD_STOP);
                new Handler().post(() -> {
                    stopRecorder();
                });
                if (error != null) {
                    Log.w(TAG, "Recorder error ! See logcat for more details");
                    error.printStackTrace();
                    output.delete();
                } else {
                    Log.i(TAG,"ScreenRecorder.Callback onstop error="+error +" output="+ output);
                    saveRecordMedia(output);
                }
            }

            @Override
            public void onStart() {
            }

            @Override
            public void onRecording(long presentationTimeUs) {
            }
        });
        return r;
    }

    public void stop() {
        stopRecorder();
    }

    private void startRecorder() {
        if (mRecorder == null) return;
        mRecorder.start();
    }

    private void stopRecorder() {
        if (mRecorder != null) {
            mRecorder.quit();
        }
        mRecorder = null;
    }

    private void saveRecordMedia(File output) {
        if (output.exists()) {
            Message msg = Message.obtain();
            msg.what = MSG_STORE_MEDIA;
            Bundle bundle = new Bundle();
            bundle.putString(KEY_MEDIA_RECORD_PATH, output.getAbsolutePath());
            msg.setData(bundle);
            mainHandler.sendMessage(msg);
        }
    }

    private void sendTimeoutMsg() {
        boolean anytime = PreferenceManager.getDefaultSharedPreferences(mContext).
                getBoolean(Constant.KEY_RECORD_ANYTIME, false);
        if (anytime) {
            return;
        }
        int recordTime = getConfig("record_duration", 10);
        if (mainHandler != null) {
            mainHandler.removeMessages(MSG_RECORD_TIME_OUT);
            mainHandler.sendEmptyMessageDelayed(MSG_RECORD_TIME_OUT, recordTime * 1000);
        }
    }

    private MediaQualityItem getMeiaQualityItem() {
        int id = getConfig("quality", 0);

        for (MediaQualityItem item : mList) {
            if (id == item.getId()) {
                return item;
            }
        }
        return null;
    }

    private void disableAutoRotation() {
        boolean isAutoRotate = Settings.System.getInt(mContext.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) == 1;
        Log.d(TAG, "===== start: isAutoRotate = " + isAutoRotate + " =====");
        SCApplication.IS_AUTOROTATE = isAutoRotate;
        // 关闭自动旋转
        if (isAutoRotate) {
            Display d = ((WindowManager) mContext.getSystemService(WINDOW_SERVICE)).getDefaultDisplay();
            Settings.System.putInt(mContext.getContentResolver(), Settings.System.USER_ROTATION, d.getRotation());
            Settings.System.putInt(mContext.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0);
        }
    }

    private void recoveryAutoRotation() {
        if (SCApplication.IS_AUTOROTATE) {
            // 恢复自动转屏
            Settings.System.putInt(mContext.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 1);
        }
    }

    private int getConfig(String key, int def) {
        int formatValue = def;
        String value = PreferenceManager.getDefaultSharedPreferences(mContext).
                getString(key, String.valueOf(def));
        try {
            formatValue = Integer.valueOf(value);
        } catch (Exception e) {

        }
        return formatValue;
    }

    private static final String RECORD_SHARE_SUBJECT_TEMPLATE = "Record (%s)";
    private static final String CHANNEL_ID = "channel_id";
    private static final String CHANNEL_NAME = "channel_much";
    private static final String SCREENSHOT_URI_ID = "android:screenshot_uri_id";

    private static void storeMedia(Context context, String filePath) {
        Log.i(TAG, "storeMedia filePath= " + filePath);
        if (TextUtils.isEmpty(filePath) || !new File(filePath).exists()) {
            return;
        }
        // Save the screenshot to the MediaStore
        ContentValues values = new ContentValues();
        ContentResolver resolver = context.getContentResolver();
        values.put(MediaStore.Video.VideoColumns.DATA, filePath);
        values.put(MediaStore.MediaColumns.SIZE, filePath.length());
        values.put(MediaStore.Video.VideoColumns.MIME_TYPE, "video/mp4");
        String pkgName = RecordUtil.getAppPkgName(context);
        String appName = RecordUtil.getAppName(context, pkgName);
        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(System.currentTimeMillis()));
        String subject = String.format(RECORD_SHARE_SUBJECT_TEMPLATE, subjectDate);
        values.put(MediaStore.Video.VideoColumns.DESCRIPTION, pkgName + "," + appName);
        Uri uri = resolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);

        try {
            Bitmap picture = getVideoThumb(filePath);

            //show record notifycation
            if (uri != null) {
                showRecordNotifycation(context, subject, uri, picture);
            }
        } catch (Exception e) {
            Log.e(TAG, "storeMedia e = " + e.getMessage());
        }
    }


    private static Bitmap getVideoThumb(String path) {

        MediaMetadataRetriever media = new MediaMetadataRetriever();

        media.setDataSource(path);  // 如果开始录屏，然后立即暂停，会报错setDataSource failed: status = 0xFFFFFFEA

        return media.getFrameAtTime();

    }

    private static void showRecordNotifycation(Context context, String subject, Uri uri, Bitmap picture) {
        NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
        final long now = System.currentTimeMillis();
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_LOW);
            mNotificationManager.createNotificationChannel(channel);
        }
        // Setup the notification
        Notification.BigPictureStyle mNotificationStyle = new Notification.BigPictureStyle()
                .bigPicture(ReflectUtil.createAshmemBitmap(picture));

        // The public notification will show similar info but with the actual screenshot omitted
        Notification.Builder builder;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            builder = new Notification.Builder(context, CHANNEL_ID);
        } else {
            builder = new Notification.Builder(context);
        }
        // Create the intent to show the screenshot in gallery
        Intent launchIntent = new Intent(Intent.ACTION_VIEW);
        launchIntent.setDataAndType(uri, "video/mp4");
        launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        Notification.Builder mPublicNotificationBuilder = builder
                .setContentTitle(context.getString(R.string.record_saved_title))
                .setContentText(context.getString(R.string.record_saved_text))
                .setContentIntent(PendingIntent.getActivity(context, 0, launchIntent, 0))
                .setSmallIcon(R.drawable.stat_notify_image)
                .setCategory(Notification.CATEGORY_PROGRESS)
                .setWhen(now)
                .setAutoCancel(true)
                .setShowWhen(true)
                .setColor(context.getColor(Resources.getSystem().getIdentifier("system_notification_accent_color", "color", "android")));
        SCApplication.overrideNotificationAppName(context, mPublicNotificationBuilder);
        Notification.Builder newbuilder;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            newbuilder = new Notification.Builder(context, CHANNEL_ID);
        } else {
            newbuilder = new Notification.Builder(context);
        }
        Notification.Builder mNotificationBuilder = newbuilder
                .setContentTitle(context.getString(R.string.record_saved_title))
                .setContentText(context.getString(R.string.record_saved_text))
                .setSmallIcon(R.drawable.stat_notify_image)
                .setContentIntent(PendingIntent.getActivity(context, 0, launchIntent, 0))
                .setWhen(now)
                .setShowWhen(true)
                .setColor(context.getColor(Resources.getSystem().getIdentifier("system_notification_accent_color", "color", "android")))
                .setStyle(mNotificationStyle)
                .setAutoCancel(true)
                .setPublicVersion(mPublicNotificationBuilder.build());
        ReflectUtil.setFlag(mNotificationBuilder, Notification.FLAG_NO_CLEAR, false);
        SCApplication.overrideNotificationAppName(context, mNotificationBuilder);

        Intent sharingIntent = new Intent(Intent.ACTION_SEND);
        sharingIntent.setType("video/mp4");
        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);
        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);

        // Create a share action for the notification
        PendingIntent chooseAction = PendingIntent.getBroadcast(context, 0,
                new Intent(context, GlobalScreenshot.TargetChosenReceiver.class),
                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
        Intent chooserIntent = Intent.createChooser(sharingIntent, null,
                chooseAction.getIntentSender())
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        PendingIntent shareAction = PendingIntent.getActivity(context, 0, chooserIntent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        Notification.Action.Builder shareActionBuilder = new Notification.Action.Builder(
                R.drawable.ic_screenshot_share,
                context.getString(Resources.getSystem().getIdentifier("share", "string", "android")), shareAction);
        mNotificationBuilder.addAction(shareActionBuilder.build());

        // Create a delete action for the notification
        PendingIntent deleteAction = PendingIntent.getBroadcast(context, 0,
                new Intent(context, GlobalScreenshot.DeleteScreenshotReceiver.class)
                        .putExtra(SCREENSHOT_URI_ID, uri.toString()),
                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
        Notification.Action.Builder deleteActionBuilder = new Notification.Action.Builder(
                R.drawable.ic_screenshot_delete,
                context.getString(Resources.getSystem().getIdentifier("delete", "string", "android")), deleteAction);
        mNotificationBuilder.addAction(deleteActionBuilder.build());

        mNotificationBuilder.setLargeIcon(ReflectUtil.createAshmemBitmap(picture));
        mNotificationStyle.bigLargeIcon((Bitmap) null);
        mNotificationManager.notify(R.id.notification_screenshot, mNotificationBuilder.build());
    }
}

```

